## SpringCloud

## Hystrix断路器

### 概念

- 服务雪崩

  多个微服务之间调用的时间，微服务A调用B和C，B和C又分别调用其他微服务，这就是所谓的**扇出**。如果扇出的连路上某个微服务的响应时间过长或者不可用，对微服务A的调用就会占用越来越多系统资源，进而引起系统

- 服务降级

  - 配置@HystrixCommand，里面写fallbackMethod
  - 服务器忙，可能遇到超时或者异常，为了不使整个调用链瘫痪，可以立即返回一个友好的提示，fallback，租到超时不等待，出错有兜底
  - 哪些场景会用到
    - 程序运行异常
    - 超时
    - 服务熔断触发服务降级
    - 线程池/信号量打满

- 服务熔断

  - 应对雪崩效应的一种链路保护机制，当扇出链路某服务出错或响应时间太长，会进行服务降级，进而熔断该节点微服务的调用，快速返回错误的响应信息
  - 检测到节点微服务调用正常，恢复调用链路
  - 缺省值是5s20次调用失败，启动熔断
  - 类比保险丝，当服务达到最大访问负载，直接拒绝访问，然后调用降级的方式返回友好提示
  - 服务降级->进而熔断->恢复调用链路

- 服务限流

  - 秒杀高并发等操作，严禁突然一窝蜂的访问，需要排队，有序进行

## Ribbon

一套客户端的负载工具

提供客户端的软件负载均衡算法，将其他组件服务连接在一起。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单地说，就是在配置文件中列出Load Balancer后面所有的机器，ribbon会自动帮助基于某种规则，如简单轮询，随机算法去连接这些机器。我们也很容易使用ribbon实现自定义的负载均衡算法

### 自定义



## Feign

使编写HTTP客户端变得容易。

实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端来包装对依赖服务的调用

在feign的定义下，我们只需要创建一个接口并使用注解的方式来配置，在微服务接口上标注一个Feign注解，即可完成对服务提供方的接口绑定，简化了使用ribbon时自行封装服务调用客户端的开发量

与ribbon不同， 通过reign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现服务调用

### Feign与openFeign区别

openFeign在feign的基础上支持了SpringMVC注解，@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务

### openFeign超时设置

openFeign默认等待1s，超时后报错，需要单独设置超时时间

## Eureka

### 服务注册发现

包含两个组件

- eureka server 
  - 提供服务注册服务，各个微服务节点启动后向eureka注册，这样eureka中的服务注册表中将会存储所有可用服务节点的信息
- eureka client
  - 简化了eureka server的交互，客户端同时也具备一个内置使用轮询的负载算法的负载均衡器。应用启动后，将会向eureka server发送心跳（默认周期是30s），如果多个周期内server没有收到心跳，将会把该服务节点移除（默认90秒）

### 自我保护

用于一组客户端和服务之间存在网络分区场景下的保护，一旦进入保护模式，eureka server将会保护其服务注册表中的信息，不再删除服务注册表中的数据，也不会注销任何服务

- 为什么要有保护机制
  - 为了防止因为网络问题，EurekaServer将client剔除
  - 满足AP
- 如何保护
  - 默认如果到达90s没有收到心跳就会剔除服务，但是如果者90s内有大量的服务实例都丢失了心跳，server就会开启保护机制
- 如何关闭
  - eureka.server.enable-self-preservation=false